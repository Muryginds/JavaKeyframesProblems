# Решение 91. Decode Ways


## Детали 
Рассмотрим входную строку `1264`

Если использовать бумагу и ручку, то мы найдем следующие
варианты деления строки на коды букв. Для упрощения будем
писать только числа:

- `1 2 6 4` - любое число можно разбить на отдельные цифры,
если в нем нет нуля
- `12 6 4` - объединяя одну группу, остальные могут быть 
разделены по одной цифре
- `1 26 4`

Собрать из последних двух цифр число не может, так как
максимальное двузначное значение = 26.

В итоге можно собрать только 3 варианта.

Если бы в числе был бы один ноль, например `1064`, в этом
случае мы уже не можем разбить на отдельные цифры, всегда
`10` должно включаться в любую последовательность.

## Использование динамического программирования

Если рассмотреть наше число `1264`, то мы можем разделить
на отдельные цифры и собирать из них итоговое число.

Количество возможных вариантов на каждом шаге будем
записывать в массив и начнем с конца строки.

`[0,0,0,0]`

1. `4` можно использовать как код, так как > 0 и < 27,
запишем 1

`[0,0,0,1]`

2. Добавляем `6`, так как это не `0`, то предыдущее значение
добавляем в предпоследнюю ячейку:

`[0,0,1,1]`

Если собрать двузначное число `64` - оно нам не подходит,
так как > 26. Больше ничего не добавляем.

3. Берем следующую цифру - `2`. Она не `0`, значит записываем
предыдущее значение в соответсвующую ячейку:

`[0,1,1,1]`

Проверяем двузначное число `20` - оно может существовать.
Это означает, что если мы отдельно берем `20`, то
различных наборов с использованием `20` это значение
вариантов после `0`, в нашем случае это 1 - последнее значение
в массиве. Суммируем это значение:

`[0,2,1,1]`

4. Используем следующую цифру `1`. Она не ноль, поэтому
берем предыдущее значение:

`[1,2,1,1]`

Можем ли мы собрать двузначное число? Да, так как оно `12`.
А значит добавляем к нему предпредыдущее `1`:

`[3,2,1,1]`

Ответ будет значение по индексу 0 в массиве.

## Еще один пример

Для упрощения кода алгоритма и уменьшения проверок,
создадим массив с результатом на одну ячейку больше и
в последнюю ячейку запишем 1. В предпоследнюю запишем
0 или 1, в зависимости от последней цифры (0 или нет)

```
[2 4 1 0 6 2 1]
[0,0,0,0,0,0,1,1]
```

Таким образом мы сразу определили, возможно ли собрать
последовательность из одной последней цифры.

Поочереди проходим каждую цифру и результат записываем в
соответсвующую ячейку:

### 2

`2 != 0` добавляем 1 (значение по индексу -1)
`21 - ok` добавляем 1 (значение по индексу -2)

```
[2 4 1 0 6 2 1]
[0,0,0,0,0,2,1,1]
```

### 6

`6 != 0` добавляем 2 (значение по индексу -1)
`62 - not ok` ничего не делаем

```
[2 4 1 0 6 2 1]
[0,0,0,0,2,2,1,1]
```

### 0

`0 == 0` ничего не делаем
`06 - not ok` ничего не делаем

```
[2 4 1 0 6 2 1]
[0,0,0,0,2,2,1,1]
```

### 1

`1 != 0` добавляем 0 (значение по индексу -1)
`10 - ok` добавляем 2 (значение по индексу -2)

```
[2 4 1 0 6 2 1]
[0,0,2,0,2,2,1,1]
```

### 4

`4 != 0` добавляем 2 (значение по индексу -1)
`41 - not ok` ничего не делаем

```
[2 4 1 0 6 2 1]
[0,2,2,0,2,2,1,1]
```

### 2

`2 != 0` добавляем 2 (значение по индексу -1)
`24 - ok` добавляем 2 (значение по индексу -2)

```
[2 4 1 0 6 2 1]
[4,2,2,0,2,2,1,1]
```

**Количество возможных комбинаций: 4**

> Если число состоит из невозможной комбинации,
например подряд два 0, то просто после этих двух нулей
весь ряд будет содержать одни нули. Отдельных проверок
поэтому не требуется.


